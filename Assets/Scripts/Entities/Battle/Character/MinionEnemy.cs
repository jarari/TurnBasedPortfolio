using UnityEngine;
using TurnBased.Battle;
using TurnBased.Battle.Managers;
using TurnBased.Data;
using UnityEngine.Playables;
using System.Collections;
using Unity.Cinemachine;


namespace TurnBased.Entities.Battle { 
    
    // 일반 몬스터
    public class MinionEnemy : Character
    {
        [Header("Timelines")]
        public PlayableDirector normalAttack;    // 일반 공격 애니메이션
        public PlayableDirector skillAttack;        // 스킬 공격 애니메이션       

        [Header("Components")]
        public Animator animator;   // 캐릭터의 애니메이터

        // 본인의 위치와 회전값을 담을 변수
        private Vector3 EnPosition;
        private Vector3 EnRotate;

        // 캐릭터의 마지막 공격 상태를 담을 변수
        private CharacterState _lastAttack;

        

        // 공격후에 애니메이션이 끝날 때의 반환을 처리하는 코루틴
        private IEnumerator DelayReturnFromAttack()
        {            
            // 일시 정지 없이 다음 프레임에서 실행함
            yield return null;
            // 마지막 공격 상태가 DoAttack 일 경우
            if (_lastAttack == CharacterState.DoAttack)
            {
                // 일반 공격 애니메이션을 끝까지 진행시킨다
                normalAttack.time = normalAttack.duration;
                // 타임라인을 현재 시간에 맞게 상태를 업데이트
                normalAttack.Evaluate();
            }
            // 마지막 공격 상태가 CastSkill 일 경우
            else if (_lastAttack == CharacterState.CastSkill)
            {
                // 스킬 공격 애니메이션을 끝까지 진행시킨다
                skillAttack.time = skillAttack.duration;
                // 타임라인을 현재 시간에 맞게 상태를 업데이트
                skillAttack.Evaluate();
            }          
        }

        // 애니메이션 이벤트가 발생했을경우 처리하는 함수
        private void OnAnimationEvent_Impl(Character c, string animEvent, string payload)
        {
            // 타임라인에서 데미지 시그널을 받게 된다면 실행
            if (animEvent == "Damage")
            {
                var player = TargetManager.instance.Target;

                // 자기자신의 캐릭터를 가져온다
                Character ch = GetComponent<Character>();
                // 데미지를 계산하는 함수를 호출하고
                DamageResult result = CombatManager.DoDamage(ch, player);

                Debug.Log(player.name + " 에게 " + result.FinalDamage + " 데미지");

                // 플레이어의 데미지 함수에 때린놈을 자신으로 하고 호출
                player.Damage(this);                
            }
            // 타임라인에서 공격이 끝난 신호를 받게된다면 실행
            if (animEvent == "NormalAttackEnd" || animEvent == "SkillAttackEnd")
            {                
                // 공격후 애니메이션 처리 코루틴을 호출후
                StartCoroutine(DelayReturnFromAttack());

                Debug.Log("턴 종료");

                // 타임라인의 상태가 Pause일때 (재생이 종료 되었을때)
                if (normalAttack.state == PlayState.Paused)
                {
                    // 에너미의 부모객체를 기준으로 상대적인 위치를 0으로 맞춘다
                    meshParent.transform.localPosition = Vector3.zero;
                    // 공격하기 위해 틀었던 회전값을 원래대로 가져온다
                    meshParent.transform.eulerAngles = EnRotate;

                    Debug.Log("상대적인 위치"+ meshParent.transform.localPosition);
                    Debug.Log("절대적인 위치"+ meshParent.transform.position);

                    // 턴을 종료한다
                    EndTurn();
                }
            }
        }
        protected override void Awake()
        {
            base.Awake();

            // 이벤트가 발생했을 경우 실행될 함수를 추가한다
            OnAnimationEvent += OnAnimationEvent_Impl;
        }
        
        // 턴을 받았을때
        public override void TakeTurn()
        {
            // 부모 클래스에서 TakeTurn 실행 후 실행
            base.TakeTurn();

            // 이거 순서가 공격 준비를 먼저 시작하고 공격을 시작하면 여기가 실행이 된다
            Debug.Log("턴을 받았다!");

            
            // 강인도가 0이하 라면
            if (this.Data.stats.CurrentToughness < 0)
            {
                // 현재 강인도를 최대로 한다
                this.Data.stats.CurrentToughness = this.Data.stats.MaxToughness;                
            }
        }

        #region 행동하는 함수 (스킬, 공격, 궁극기, 엑스트라 어택)

        // 스킬을 사용할때
        public override void CastSkill()
        {
            // 부모 클래스에서 CastSkill 실행후 실행
            base.CastSkill();
            Debug.Log(gameObject.name + " 의 스킬 발동!");
                        
            // 플레이어 타겟을 가져온다
            var player = TargetManager.instance.Target;

            // 에너미가 플레이어 앞에 오도록 한다
            meshParent.transform.position = player.gameObject.transform.position - new Vector3(8.47f, 0f);

            // 에너미가 플레이어를 바라보게한다
            meshParent.transform.forward = player.gameObject.transform.position;

            
            // 스킬 공격 애니메이션 재생
            skillAttack.Play();

            // 마지막 공격이 스킬공격임을 알린다
            _lastAttack = CharacterState.CastSkill;
                        

            // 자기자신의 캐릭터를 가져온다
            Character ch = GetComponent<Character>();
            // 데미지를 계산하는 함수를 호출하고
            DamageResult result = CombatManager.DoDamage(ch, player);

            Debug.Log(player.name + " 에게 " + result.FinalDamage + " 데미지");

            // 플레이어의 데미지 함수에 때린놈을 자신으로 하고 호출
            player.Damage(this);

        }
      
        // 공격을 시작할때
        public override void DoAttack()
        {
            base.DoAttack();
            Debug.Log("Enemy Attack");

            // 플레이어 타겟을 가져온다 (1인)
            var player = TargetManager.instance.Target;

            // 에너미가 플레이어 앞에 오도록 한다
            meshParent.transform.position = player.gameObject.transform.position - new Vector3(8.47f,0f);

            // 에너미가 플레이어를 바라보게한다
            meshParent.transform.forward = player.gameObject.transform.position;

            // 현제 공격을 진행하는 자신의 이름 (테스트용)
            Debug.Log(gameObject.name + " 의 공격! ");            
            
            // 일반공격 애니메이션이 실행
            normalAttack.Play();
            
            // 마지막 공격이 일반공격임을 보낸다
            _lastAttack = CharacterState.DoAttack;
            
        }

        // 엑스트라 어텍을 할때
        public override void DoExtraAttack()
        {
            base.DoExtraAttack();
        }

        #endregion


        #region 준비하는 함수 (공격, 스킬, 궁극기)

        // 공격을 준비하는 함수
        public override void PrepareAttack()
        {
            base.PrepareAttack();

            // 턴을 받았을때 에너미의 현재 위치와 회전값을 저장한다            
            EnRotate = meshParent.transform.eulerAngles;

            // 타겟을 세팅한다
            TargetManager.instance.ChangeTargetSetting(TargetManager.TargetMode.Single, CharacterTeam.Player);            
            // 공격하는 함수
            DoAttack();
        }
        // 스킬을 준비하는 함수
        public override void PrepareSkill()
        {
            base.PrepareSkill();
            // 타겟을 세팅한다 (일단 대상을 단일로)
            TargetManager.instance.ChangeTargetSetting(TargetManager.TargetMode.Single, CharacterTeam.Player);
            // 스킬을 사용하는 함수
            CastSkill();
        }
        // 궁극기를 준비하는 함수
        public override void PrepareUltAttack()
        {
            base.PrepareUltAttack();
        }

        #endregion

        // 혹시 몰라서 만든 데미지 함수 (때린 놈의 정보를 가져온다)
        // IDamageApply를 상속시켜 가져왔다
        public override void Damage(Character pl)
        {
            // 부모 클래스의 DagageApply를 실행후 실행
            base.Damage(pl);

            // 자기자신의 캐릭터를 가져온다
            Character ch = GetComponent<Character>();
            // 데미지를 계산하는 함수를 호출 (때린놈, 맞은놈)
            DamageResult result = CombatManager.DoDamage(pl, ch);

            // 데미지 애니메이션의 트리거를 켠다
            animator.SetTrigger("Damage");

            // 만약 강인도가 있다면
            if (ch.Data.stats.CurrentToughness > 0)
            {               

                // 채력을 최종적으로 받는 데미지의 반으로 받고
                this.Data.stats.CurrentHP -= (result.FinalDamage / 2);

                // 채력이 만약 0이하가 되었다면
                if (ch.Data.stats.CurrentHP <= 0)
                {
                    // 죽음을 다룰 함수를 실행한다
                    Dead();
                }

                // 플레이어가 약점 속성으로 때린다면
                if (Element_Check(pl, ch) == true)
                {
                    // 에너미의 강인도는 플레이어의 공격력만큼 깎인다
                    this.Data.stats.CurrentToughness -= result.NormalAttack;

                    // 강인도가 만약 0이하가 되었다면
                    if (ch.Data.stats.CurrentToughness <= 0)
                    {
                        // 현재 강인도를 0으로 만든다
                        ch.Data.stats.CurrentToughness = 0;
                        // 그로기를 다룰 함수를 실행한다
                        Groggy();
                    }

                }

            }
            // 만약 강인도가 없다면
            else
            {
                // 에너미는 최종적으로 받는 데미지를 모두 받는다.
                this.Data.stats.CurrentHP -= result.FinalDamage;

                // 채력이 만약 0이하가 되었다면
                if (ch.Data.stats.CurrentHP <= 0)
                {
                    // 죽음을 다룰 함수를 실행한다
                    Dead();
                }

            }
        }
        // 사망시 함수
        public override void Dead()
        {
            base.Dead();

            // 사망 에니메이션의 트리거를 켠다
            animator.SetTrigger("Dead");
            // 캐릭터 모델을 비활성화
            SetVisible(false);
            
        }


        // 그로기 함수
        public override void Groggy()
        {
            base.Groggy();
            // 그로기 애니메이션 트리거를 켠다
            animator.SetTrigger("Groggy");

            // 현재 스피드와 방어력을 절반으로 한다
            Data.stats.Speed = (Data.stats.Speed) / 2;
            Data.stats.Defense = (Data.stats.Defense) / 2;
        }

    }



}